# 백준[1940](https://www.acmicpc.net/problem/1940)
## 문제

주몽은 철기군을 양성하기 위한 프로젝트에 나섰다. 그래서 야철대장을 통해 철기군이 입을 갑옷을 만들게 하였다. 야철대장은 주몽의 명에 따르기 위하여 연구에 착수하던 중 아래와 같은 사실을 발견하게 되었다.

갑옷을 만드는 재료들은 각각 고유한 번호를 가지고 있다. 갑옷은 두 개의 재료로 만드는데 두 재료의 고유한 번호를 합쳐서 M(1 ≤ M ≤ 10,000,000)이 되면 갑옷이 만들어 지게 된다. 야철대장은 자신이 만들고 있는 재료를 가지고 갑옷을 몇 개나 만들 수 있는지 궁금해졌다. 이러한 궁금증을 풀어 주기 위하여 N(1 ≤ N ≤ 15,000) 개의 재료와 M이 주어졌을 때 몇 개의 갑옷을 만들 수 있는지를 구하는 프로그램을 작성하시오.

## 입력
첫째 줄에는 재료의 개수 N(1 ≤ N ≤ 15,000)이 주어진다. 그리고 두 번째 줄에는 갑옷을 만드는데 필요한 수 M(1 ≤ M ≤ 10,000,000) 주어진다. 그리고 마지막으로 셋째 줄에는 N개의 재료들이 가진 고유한 번호들이 공백을 사이에 두고 주어진다. 고유한 번호는 100,000보다 작거나 같은 자연수이다.

## 출력
첫째 줄에 갑옷을 만들 수 있는 개수를 출력한다.

## 풀이
주어진 제료를 정렬하여고 앞뒤로 중려가면서 계산하는 문제다 여기서는 오름차순으로 정렬 한 기준으로 설명하겠다.  
주어진 재료가 [2,7,4,1,5,3]이고 M이 9일때 이를 오름차순으로 정렬하면 [1,2,3,4,5,7]이 된다.  

그 뒤 아래와 같은 과정을 거친다.
1. 앞에서 하나를 가져오고 뒤어서 하나를 가져와서 더한다.
1. 그 합이 M과 같으면 갑옷을 만들 수 있는 조합이므로 두 재료를 빼낸다.
1. 합이 M보다 작으면 앞에서 가져온 재료로는 만들 수 없으므로 앞에서 가져온 재료를 뺀다.
1. 합이 M보다 크면 뒤에서 가져온 재료로는 만들 수 없으므로 앞에서 가져온 재료를 뺀다.
1. 부족한 부분의 재료의 다음 재료를 가져와 2~4.의 과정을 다시 거친다.
1. 더 이상 가져올 재료가 부족하면 멈춘다.

이때 2번과정을 몇번 거치는지 세어서 몇개의 갑옷을 만들 수 있는지 세어준다.

여기서 나는 파이선에 내장되어있는 정렬를 쓰면되지만 그냥 병합정렬이 쓰고 싶어서 병합정렬을 구현하여 사용했다. 불만 있으면 sort를 사용하건 sorted를 사용하건 그거 써라 전체코드는 [여기](./c.py)를 보면 된다.

```python
def solution():
	N = int(input().strip())
	M = int(input().strip())
	L = list(map(int,input().strip().split()))
	tmp = [0]*len(L)
	l = 0
	r = len(L)-1
	ans = 0

	msort(L,tmp,0,len(L))

	while(l < r):
		if(L[l]+L[r] < M):
			l += 1
		elif(L[l]+L[r] > M):
			r -= 1
		else:
			ans += 1
			l += 1
			r -= 1
	
	return ans
```

## 잡담
왜 병합정렬 구현해서 쓰냐 하면 C++은 stable_sort라는 안정정렬도 제공하지만 sort하면 퀵 정렬을 제공하기에 속도는 빠르지만 최악의 케이스에는 시간이... 그리고 최근에 STL못쓰게 하는 문제 강제로 푼적이 있어서 습관이 되어 버렸다... 뭐 알아서 나쁠건 없으니 좋은게 좋은거라 하자.  
그리고 제발 ++나 --문법좀... 단항연산자 얼마나 좋아... 연산자 재정의 없나..? 재정의 하려 해도 없어서 못하나..?