# 백준[1377](https://www.acmicpc.net/problem/1377)
## 문제
버블 소트 알고리즘을 다음과 같이 C++로 작성했다.
```c++
bool changed = false;
for (int i=1; i<=N+1; i++) {
    changed = false;
    for (int j=1; j<=N-i; j++) {
        if (A[j] > A[j+1]) {
            changed = true;
            swap(A[j], A[j+1]);
        }
    }
    if (changed == false) {
        cout << i << '\n';
        break;
    }
}
```
위 소스에서 N은 배열의 크기이고, A는 정렬해야 하는 배열이다. 배열은 A[1]부터 사용한다.

위와 같은 소스를 실행시켰을 때, 어떤 값이 출력되는지 구해보자.

## 입력
첫째 줄에 N이 주어진다. N은 500,000보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 A[1]부터 A[N]까지 하나씩 주어진다. A에 들어있는 수는 1,000,000보다 작거나 같은 자연수 또는 0이다
## 출력
정답을 출력한다
## 풀이
문제를 분석해 보면 오름차순으로 버블정렬을 만들고 정렬을 하는 과정에서 몇 번의 정렬 과정 또는 몇 번째 큰 수가 정렬이 될 때 정렬이 완료되는가를 확인하는 문제이다.

그래서 버블정렬을 구현하여 해당 값을 구하고자 한다면 배열의 크기의 범위가 500,000이므로 배열이 내림차순으로 정렬되어 있으면 최악의 경우가 되어 500,000<sup>2</sup>의 과정이 필요하여 2초라는 시간으로는 부족하다는 것을 알 수 있다.

그러므로 다른 방법을 찾아봐야 하는데 버블정렬을 보면 배열의 길이가 $N$ 인 배열 $A$ 의 $i$ 번째 큰 수를 오름차순으로 정렬한다 하였을 때 $A_i$ 미만의 모든 $A_x$들은 정렬되었을 때의 자기의 위치 방향으로 한 칸씩 움직인다는 것을 볼 수 있다. 즉 모든 $A_x$ 는 정렬되기 전과 후의 위치 차이만큼 정렬을 진행하면 각 수가 정렬이 되므로 차이가 가장 큰 수가 정렬이 완료되면 모든 수가 정렬이 완료된다 할 수 있다.

다만 여기서 말하는 차이는 정렬 후 - 정렬 전을 이야기한다 이유는 정렬 전 위치가 $x$ 이고 후의 위치가 $y$ 라 하면 $x$ < $y$ 인 상황은 $A_x$ 가 $i$번째 큰 수 일 때 정렬이 되는 수 이거나 중간에 정렬이 완료되는 수라서 이 수는 정렬 과정이 0 또는 1이므로 제외할 필요가 있기 때문이다.
```python
def solution():
	N = int(input())
	sort_table = [[] for _ in range(1000001)]
	sort_arr = []
	sort_dict = {}

	for i in range(N):
		v = int(input())
		sort_table[v].append(i)
	for v in sort_table:
		if(v):
			sort_arr += v

	ans = 0

	for i in range(N):
		ans = max(ans, sort_arr[i] - i)
	
	return ans+1
```

## 잡담
$N$방식 정렬 써서 했는데 그래도 역시 크기가 크니 속도가 안나오나??? 허허....