# 백준[2164](https://www.acmicpc.net/problem/2164)
## 문제

N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.

이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.

예를 들어 N=4인 경우를 생각해 보자. 카드는 제일 위에서부터 1234 의 순서로 놓여있다. 1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 마지막으로 2를 버리고 나면, 남는 카드는 4가 된다.

N이 주어졌을 때, 제일 마지막에 남게 되는 카드를 구하는 프로그램을 작성하시오.

## 입력
첫째 줄에 정수 N(1 ≤ N ≤ 500,000)이 주어진다.

## 출력
첫째 줄에 남게 되는 카드의 번호를 출력한다.

## 풀이
수학적으로 계산하는 방법이 있는것 같지만 나는 규칙과 큐를 이용하여 풀었다.  
1. 규칙  
크기가 홀수인 배열과 짝수인 배열로 나누어 생각할 수 있다.
    1. 크기가 짝수인 경우  
    배열 A가 [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]라 가정해보자 이를 문제에 주어진 규칙을 따라 재배치를 배열의 크기의 반인 8번 진행을 해보면 A는 [2,4,6,8,10,12,14,16]만 남는다.  
    다시 크기의 반인 4번 진행을 해보면 A는 [4,8,12,16]가 된다.  
    한번 더 크기의 반인 2번 진행을 해보면 A는 [8,16]이 된다.  
    자세히 보면 크기의 절반 만큼 진행 하면 A의 짝수 번째 값들만 남는 것을 볼 수 있다.
    1. 배열 A가 [1,2,3,4,5,6,7]라 가정해보자 이를 문제에 주어진 규칙을 따라 재배치를 배열의 크기의 반(내림)인 3번 진행을 해보면 A는 [7,2,4,6]만 남는다.  
    배열 A가 [1,2,3,4,5]라 가정해보자 이를 문제에 주어진 규칙을 따라 재배치를 배열의 크기의 반(내림)인 2번 진행을 해보면 A는 [5,2,4]만 남는다.  
    배열 A가 [1,2,3]라 가정해보자 이를 문제에 주어진 규칙을 따라 재배치를 배열의 크기의 반(내림)인 1번 진행을 해보면 A는 [3,2]만 남는다.  
    자세히 보면 크기의 절반(내림) 만큼 진행 하면 A의 [마지막 원소, 짝수 번째 값]의 형태가 남는 것을 볼 수 있다.

    위와 같은 규칙성이 있으므로 A를 위와 같은 규칙을 통해 절반씩 줄여 나가면서 1개가 남을때까지 진행 하고 한개가 남으면 그것을 출력한다.

    ```python
    def solution(deck):
        while(len(deck)>1):
            tmp = [v for i, v in enumerate(deck) if i%2 == 1]
            if len(deck)%2 ==1:
                tmp = [deck[-1]]+tmp
            deck = tmp
        return deck[0]
    ```
1. 큐
    큐의 특징을 보면 FIFO(LILO)의 특징을 가지는 것으로 먼저 들어온 것이 먼저 나간다. 이 점을 문제에 대입하면 카드를 위에서 쌓는 것이 아닌 아래에 넣는 식으로 쌓는다 생각하면 먼저 들어온것 위 나중에 들어온 것 아래가 될 것이다.  
    그럼 위에 카드를 버리는 것은 먼저 들어온 카드를 버린다 보면 되고 위의 카드를 아래로 내리는 것은 먼저 들어온 카드를 빼서 아래로 내린다는 이야기가 된다.  
    이를 적용하여 카드가 한장 남을때 까지 문제에 주어진 동작을 처리하는 과정을 좀 변형 해서 해보면 두번째로 들어온 카드를 빼서 아래에 넣고 가장 먼저 들어온 카드를 버리는 행위와 같다 볼 수 있다.  
    이를 기준으로 구현해 보면  

    ### 큐
    큐의 노드는 값과 그 다음 원소를 가리키는 포인터를 준비해 준다.  

    큐의 먼저 들어온 원소는 front로 지정해주어 먼저 들어온 원소에 접근할 수 있도록 지정한다.  
    삭제시 front부터 마지막 원소를 찾으면 오래 걸리므로 마지막에 들어온 원소는 top로 선언하여 삽입도 바로 될 수 있도록 해준다.

        node = 카드
        node val = 카드번호
        node next = 다음 카드(아래에 있는 카드)
        queue front = 최근에 들어온 카드
        queue top = 마지막에 들어온 카드
    ### 삽입
    top의 아래에 카드를 넣고 top은 그 카드를 가리킨다. <b>단 비어있을 경우 새로 들어오는 카드가 처음이자 마지막 카드이므로 front도 top도 그 카드를 가리킨다.</b>

    ### 삭제
    문제에 주어진 동작을 하게되면 위에서 두장을 뽑아서 처음건 버리고 다음 카드는 맨 아래로 돌려주므로 top 아래에 fornt의 아래 카드를 넣어주고(이때 이 카드는 다음 카드를 3번째 들어온 카드를 가리키므로 아무것도 안 가리키게 바꾸어야 한다.) top은 그 카드를 가리킨다. 그리고 front는 3번째 카드를 가리키게 한다.

    이런 식으로 구현하여 쌓고 지워가면서 하나가 남을 때 까지 진행 후 하나가 남으면 그 카드는 front이자 top이므로 그 카드 번호를 출력해 준다.

    ```python
    class Card:
        def __init__(self, val, next = None) -> None:
            self.val = val
            self.next = next

    class MyDeck:
        def __init__(self) -> None:
            self.front = None
            self.top = None
            self.size = 0
            self.empty = False
        
        def push(self, val:int) -> None:
            if(not self.empty):
                self.front = self.top = Card(val)
                self.empty = True
            else:
                self.top.next = Card(val)
                self.top = self.top.next
            self.size += 1

        def pop(self) -> bool:
            if(self.size > 1):
                self.top.next = self.front.next
                self.front = self.front.next.next
                self.top = self.top.next
                self.top.next = None
                self.size -= 1
                return True

            self.front = None
            self.top = None
            self.empty = False
            return False

    def solution(deck):
        my_deck = MyDeck()
        for card in deck:
            my_deck.push(card)
        while(my_deck.size > 1):
            my_deck.pop()
        return my_deck.front.val
    ```

## 잡담
큐 잘 구현했다 생각했는데.... 이게 더 느리네... ㅋㅋㅋㅋㅋㅋㅋ  
size로 구분 하는게 아니라 front랑 top가 같을때 멈추는 식으로 해서 size변경하는 시간을 줄였어야 했나... empty도 boolean이 아니라 front나 또는 top이 none인지 확인하는 식으로 해서... ??? 왜 갑자기 지금 생각나냐... 에휴.. 2이상일때랑 2일때 다르게 한건 좋았는데 솔직히 해봤자 한번 나오는거... 그냥 하면 되는데... 속도 별로 차이 없는데.. 에휴...

그래서 해봤는데 사진속 시간 순서가

    제출 번호 48700577 잡담에서 한 이야기 구현
    제출 번호 48700577 처음 사이즈 넣고 이것저것한 큐
    제출 번호 48686944 찾은 규칙 구현한거

순서인데 이거....

![그림1](./%EC%B9%B4%EB%93%9C%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4%EC%8B%9C%EA%B0%84.png)

시간 차이 보소... 규칙이랑 큐 시간차이 엄청 나고 속도 상향 시킨 큐도 시간 얼마 안 줄어든거 이거... 하..... 왜 큐 구현함 저리 풀면 되는데..?ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ