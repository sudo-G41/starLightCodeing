# 백준[17298](https://www.acmicpc.net/problem/17298)
## 문제

크기가 N인 수열 A = A1, A2, ..., AN이 있다. 수열의 각 원소 Ai에 대해서 오큰수 NGE(i)를 구하려고 한다. Ai의 오큰수는 오른쪽에 있으면서 Ai보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오큰수는 -1이다.

예를 들어, A = [3, 5, 2, 7]인 경우 NGE(1) = 5, NGE(2) = 7, NGE(3) = 7, NGE(4) = -1이다. A = [9, 5, 4, 8]인 경우에는 NGE(1) = -1, NGE(2) = 8, NGE(3) = 8, NGE(4) = -1이다.

## 입력
첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄에 수열 A의 원소 A1, A2, ..., AN (1 ≤ Ai ≤ 1,000,000)이 주어진다.
## 출력
총 N개의 수 NGE(1), NGE(2), ..., NGE(N)을 공백으로 구분해 출력한다.
## 풀이
스택이 비어있거나 top과 비교해서 작거나 같으면 스택에 해당 인덱스를 넣고 아니면 스택에 있는 값을 pop하여 해당 인덱스를 비교한 값으로 변경해준다.  
전부 확인하였을때 남아있는 인덱스들은 오른쪽에 자기보다 큰 수가 없었다는 이야기이므로 전부 -1로 변경해준다.

```python
def solution():
    N = int(input())
    A = list(map(int,input().split()))
    NGE = [0]*N
    s = []
    for i in range(N):
        while(s):
            if(A[s[-1]] < A[i]):
                NGE[s.pop()] = A[i]
            else:
                break
        s.append(i)
    for i in s:
        NGE[i] = -1
    return NGE
```

## 잡담
사실 맨 처음 -1로 초기화 해주면 마지막 작업이 필요 없다. 나중에 알았지만 통과 되었으므로 그냥 두겠다. ㅎㅎ