# 백준[1253](https://www.acmicpc.net/problem/1253)
## 문제

N개의 수 중에서 어떤 수가 다른 수 두 개의 합으로 나타낼 수 있다면 그 수를 “좋다(GOOD)”고 한다.

N개의 수가 주어지면 그 중에서 좋은 수의 개수는 몇 개인지 출력하라.

수의 위치가 다르면 값이 같아도 다른 수이다.

## 입력
첫째 줄에는 수의 개수 N(1 ≤ N ≤ 2,000), 두 번째 줄에는 i번째 수를 나타내는 Ai가 N개 주어진다. (|Ai| ≤ 1,000,000,000, Ai는 정수)

## 출력
좋은 수의 개수를 첫 번째 줄에 출력한다.

## 풀이
그냥 투포인터 쓰면 빠르다.  
하지만 내 풀이는 값은 같지만 위치가 다른 수가 많아질수록 속도가 올라가는 투포인터 풀이다. 물론 전부 다른 값을 가지는 집합은 속도가 엄청 느려진다...  

우선 정석 풀이법을 이야기 해보자면
N이 3미만이면 조합 자체가 불가능 하므로 걸러준다.  
N이 3이상이면 아래와 같은 과정을 거쳐준다.
<sub>$X$는 $N$개의 수들의 집합</sub>

1. $X$를 정렬해준다.(여기서는 오름차순 기준)
1. 임의의 $X$의 원소 $X_n$이있을때 $i$는 0($n$=0이면 1) $j$는 $N$-$1$($n$=$N$-$1$이면 $N$-$2$)을 준비해 준다.
1. $i$ < $j$이면 
    * $X_i$ + $X_j$ < $X_n$이면 $i$를 증가시키고 3.으로 돌아간다.
    * $X_i$ + $X_j$ < $X_n$이면 $j$를 감소시킨다 3.으로 돌아간다.
    * $X_i$ + $X_j$ = $X_n$이면 좋은 수 이다.

여기서 좋은 수가 만들어지는 $n$의 개수를 세어주어 출력한다.

``` python
def answer():
	N = int(input().strip())
	if(N<3):
		input()
		return 0
	X = list(map(int, input().strip().split()))
	ans = 0
	X.sort()
	for n in range(N):
		l = 0 if n > 0 else 1
		r = N-1 if n < N-1 else N-2
		while(l<r):
			sum_num = X[l]+X[r]
			if(sum_num < X[n]):
				l += 1
				if(l == n):
					l += 1
			elif(sum_num > X[n]):
				r -= 1
				if(r == n):
					r -= 1
			else:
				ans += 1
				break
	return ans
```
그 다음으로 내 이상한 풀이를 보면

$N$개의 정수가 담긴 $X$집합을 dict를 통해 정리를 하는데 정리 기준은 key : $X$의 원소, value : 해당 Key의 개수다 된다.  
그 다음 투포인터를 이용하여 풀면 되는데 이때 주의해야 할 점이 $X_i$가 0이상의 정수였으면 $X_i$는 X<sub>i-1</sub>보다 작은 숫자들로만 만들 수 있으므로 0&sim;$i$까지만 확인하면 되지만 |$X_i$| &le; $1,000,000,000$이면서 $X_i$는 정수라 하였으니 이는 $-1,000,000,000$ &le; $X_i$ &le; $1,000,000,000$가 된다는 이야기이므로 $i$값이 어떻게 되든 $0$&sim;$N$의 범위를 확인해야 한다.  
예를 들면 {0, 1, 2, 3, 4}라는 집합이 있다고 하면 4는 3이하의 정수로, 3은 2이하의 정수로 이런 느낌으로 되지만 {-1, 0, 1}이라는 집합은 0은 -1과 1을 이용하여 만들 수 있으므로 0보다 큰 1을 이용하게 된다.  
이러한 점을 염두해 두고 투포인터를 이용하여 풀어보면 <sub>($N$개의 수가 모인 집합 $X$에서 중복된 원소를 제거하고 정렬된 집합 = $A$, $X$를 정리한 dict = $D$, 좋은 수 인지 확인하려는 수 = $k$)</sub>
1. $2$ x $A_x$ = $k$인 경우<sub>(x는 $i$ 또는 $j$이다.)</sub>
    1. $A_x$ &ne; $k$일 경우 $D_A$<sub>$_x$</sub>가 2이상일 경우 $k$는 좋은 수 조건을 만족한다.
    1. $A_x$ = $k$일 경우 $D_A$<sub>$_x$</sub>가 3이상일 경우 $k$는 좋은 수 조건을 만족한다.
1. $A_i$ + $A_j$ = $k$일 경우
    1. $A_i$ &ne; $k$ 이고 $A_j$ &ne; $k$ 인 경우 $k$는 좋은 수 조건을 만족한다.
    1. $A_i$ = $k$ 또는 $A_j$ = $k$일 경우 $D_k$가 2이상일 경우 $k$는 좋은 수 조건을 만족한다.
1. $A_i$ + $A_j$ < $k$일 경우 $i$를 증가시킨 후 좋은 수 인지 다시 확인한다.
1. $A_i$ + $A_j$ > $k$일 경우 $j$를 감소시킨 후 좋은 수 인지 다시 확인한다.
1. 위 과정을 $k$가 좋운 수 가 아니거나 $i$ &le; $j$이면 반복하여 $A$의 모든 원소 $k$가 좋은 수인지 확인한다.

```python
def solution():
	N = int(input().strip())
	A = {}
	ans = 0
	for n in map(int, input().strip().split()):
		if(n in A):
			A[n] += 1
		else:
			A[n] = 1
	
	S = list(A.keys())
	S.sort()
	
	for k in S:
		l = 0
		r = len(S)-1
		if(A[S[l]]>1 and 2*S[l] == k):
			if(S[l] != k or A[k]>2):
				ans += A[k]
		elif(A[S[r]]>1 and 2*S[r] == k):
			if(S[l] != k or A[k]>2):
				ans += A[k]
		else:
			while(l<r):
				if(S[l]+S[r] < k):
					l += 1
					if(A[S[l]]>1 and 2*S[l] == k):
						if(S[l] != k or A[k]>3):
							ans += A[k]
							break
				elif(S[l]+S[r] > k):
					r -= 1
					if(A[S[r]]>1 and 2*S[r] == k):
						if(S[r] != k or A[k]>3):
							ans += A[k]
							break
				else:
					if((S[l] != k and S[r] != k) or A[k]>1):
						ans += A[k]
						break
					else:
						l += 1
						r -= 1
	return ans
```

## 잡담